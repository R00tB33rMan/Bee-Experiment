From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Sat, 12 Nov 2022 00:05:44 +0100
Subject: [PATCH] PufferfishPR Prevent CPU busy waiting by waiting for async
 tasks

https://github.com/pufferfish-gg/Pufferfish/pull/52

diff --git a/src/main/java/gg/pufferfish/pufferfish/util/AsyncExecutor.java b/src/main/java/gg/pufferfish/pufferfish/util/AsyncExecutor.java
index 9d6dc2c80945bec9bea74714c657c7a2e0bdde9e..3ea4db15b78dab21379f3dedc0d514dadd83ad32 100644
--- a/src/main/java/gg/pufferfish/pufferfish/util/AsyncExecutor.java
+++ b/src/main/java/gg/pufferfish/pufferfish/util/AsyncExecutor.java
@@ -3,49 +3,84 @@ package gg.pufferfish.pufferfish.util;
 import com.google.common.collect.Queues;
 import gg.pufferfish.pufferfish.PufferfishLogger;
 import java.util.Queue;
-import java.util.concurrent.locks.LockSupport;
-import java.util.function.BooleanSupplier;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.logging.Level;
 
+/**
+ * <p>
+ * A simple executor that has its own thread to perform tasks on.
+ * This executor is currently only used to move some calculations required for mob spawning off the main thread
+ * ({@link net.minecraft.server.MinecraftServer#mobSpawnExecutor}).
+ * </p>
+ * <p>
+ * It uses a non-blocking {@link java.util.concurrent.ConcurrentLinkedQueue} to store its tasks.
+ * </p>
+ */
 public class AsyncExecutor implements Runnable {
-	
+
 	private Queue<Runnable> jobs = Queues.newConcurrentLinkedQueue();
 	private final Thread thread;
-	private final BooleanSupplier shouldRun;
+	// Use tryLock() instead of lock() on this lock to avoid blocking the (main) thread,
+	// because any thread will hold this lock for much shorter than the time it takes to do a context switch (~5 micros)
+	private final Lock waitLock = new ReentrantLock();
+	private final Condition waitCondition = waitLock.newCondition();
 	private volatile boolean killswitch = false;
-	
-	public AsyncExecutor(String threadName, BooleanSupplier shouldRun) {
+
+	public AsyncExecutor(String threadName) {
 		this.thread = new Thread(this, threadName);
-		this.shouldRun = shouldRun;
 	}
-	
+
+	private void signalWaiting() {
+		while (!waitLock.tryLock()) {}
+		try {
+			if (killswitch || !jobs.isEmpty()) {
+				waitCondition.signal();
+			}
+		} finally {
+			waitLock.unlock();
+		}
+	}
+
 	public void start() {
 		thread.start();
 	}
-	
+
 	public void kill() {
 		killswitch = true;
+		signalWaiting();
 	}
-	
+
 	public void submit(Runnable runnable) {
 		jobs.offer(runnable);
+		signalWaiting();
 	}
-	
+
 	@Override
 	public void run() {
 		while (!killswitch) {
-			if (shouldRun.getAsBoolean()) {
-				try {
-					Runnable runnable;
-					while ((runnable = jobs.poll()) != null) {
-						runnable.run();
+			while (!waitLock.tryLock()) {}
+			try {
+				while (!killswitch && jobs.isEmpty()) {
+					try {
+						waitCondition.await();
+					} catch (InterruptedException e) {
+						PufferfishLogger.LOGGER.log(Level.WARNING, e, () -> "Async waiting for tasks was interrupted " + thread.getName());
 					}
+				}
+			} finally {
+				waitLock.unlock();
+			}
+			Runnable runnable;
+			while ((runnable = jobs.poll()) != null) {
+				try {
+					runnable.run();
 				} catch (Exception e) {
 					PufferfishLogger.LOGGER.log(Level.SEVERE, e, () -> "Failed to execute async job for thread " + thread.getName());
 				}
 			}
-			LockSupport.parkNanos("executing tasks", 1000L);
 		}
 	}
-	
+
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index de119c3541db6a9829db51628788459108f6021f..646f3e8fb3c63add3e01667e1910eac0d3874c8b 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -302,7 +302,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public volatile boolean abnormalExit = false; // Paper
     public boolean isIteratingOverLevels = false; // Paper
 
-    public gg.pufferfish.pufferfish.util.AsyncExecutor mobSpawnExecutor = new gg.pufferfish.pufferfish.util.AsyncExecutor("MobSpawning", () -> true); // Pufferfish - optimize mob spawning
+    public gg.pufferfish.pufferfish.util.AsyncExecutor mobSpawnExecutor = new gg.pufferfish.pufferfish.util.AsyncExecutor("MobSpawning"); // Pufferfish - optimize mob spawning
 
     public static <S extends MinecraftServer> S spin(Function<Thread, S> serverFactory) {
         AtomicReference<S> atomicreference = new AtomicReference();
